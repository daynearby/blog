[{"title":"Android 7.1 应用快捷方式","date":"2017-09-10T12:29:50.000Z","path":"2017/09/10/dev-android-7-1-shortcutmanager/","text":"在Android 7.1之后添加的新功能，这里就暂且翻译成：快捷方式，简单地理解：在长按应用图标的情况下，在应用图标上显示的快捷方式，该快捷方式可以点击进入Activity，长按拖动创建一个在Launcher上的图标。 现在市场上已经是有很多应用增加了这项功能，如：印象笔记、支付宝、哔哩哔哩、IT之家、知乎、美团，以上是我的手机安装的应用中看到的，其他的就暂时没了解到，可以看一下效果。 实现有两种方式 静态方式，通过在xml中配置快捷方式，配置名称、图标、意图这些必须的参数，最后在应用启动的Activity配置一下就可以了。 动态方式，通过Android7.1新添加的ShortcutManager进行管理，可以对快捷方式进行添加、删除、更新，也可以修改上面的静态方式显示的快捷方式。 静态方式静态方式就是通过xml文件进行配置，就像ActionBar的选项一样。先配置快捷方式的选项：res/xml/static_shortcuts.xml 下面配置的参数也是比较清晰的，有：id、图标、标题、意图，还有分类，是否可用。123456789101112131415&lt;!--离线视频--&gt;&lt;shortcut android:enabled=\"true\" android:icon=\"@drawable/ic_shortcut_download\" android:shortcutDisabledMessage=\"@string/lable_shortcut_static_download_disable\" android:shortcutId=\"shortcut_id_download\" android:shortcutLongLabel=\"@string/lable_shortcut_static_download_long\" android:shortcutShortLabel=\"@string/lable_shortcut_static_download_short\"&gt; &lt;intent android:action=\"android.intent.action.VIEW\" android:targetClass=\"com.young.demo.launchershortcut.StaticShortcutDownload\" android:targetPackage=\"com.young.demo.launchershortcut\" /&gt; &lt;!--当前只有这个分类--&gt; &lt;categories android:name=\"android.shortcut.conversation\" /&gt;&lt;/shortcut&gt; 配置完图标的之后，再打开AndroidManiFest.xml配置启动的ActivityAndroidManiFest.xml12345678910&lt;activity android:name=\".MainActivity\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt; &lt;!--add static shortcut--&gt; &lt;meta-data android:name=\"android.app.shortcuts\" android:resource=\"@xml/static_shortcut\" /&gt; &lt;/activity&gt; 那么静态方式就配置好了，上面快捷方式配置的Activity的就不贴上来了，就是一个简单的Activity而已。看一下效果图： 动态方式那么动态方式，是通过ShortcutManager实现快捷方式的增加、删除、更新的操作，google的大神都配置好了方法，使用起来很简单。下面就放一下简单的配置代码。 1234567891011121314/** * 先生成一个一个的快捷方式的对象 * 对象需要配置：图标、标题、意图，其他的配置具体可以到官网查看 */ShortcutInfo likeShortcut = new ShortcutInfo.Builder(this, SHORTCUT_ID_LIKE) .setShortLabelResId(R.string.lable_shortcut_dynamic_like_short) .setLongLabelResId(R.string.lable_shortcut_dynamic_like_long) .setIcon(Icon.createWithResource(this, R.drawable.ic_shortcut_like)) .setIntent(new Intent(this, DynamicShortcutLike.class)) .build();ShortcutManager shortcutManager = getSystemService(ShortcutManager.class);//这样就可以通过长按图标显示出快捷方式了shortcutManager.setDynamicShortcuts(Arrays.asList(likeShortcut)); 上面两个是通过动态方式添加的。 移除快捷方式void removeDynamicShortcuts(@NonNull List shortcutIds); 移除快捷方式，并且拖到launcher上的图标会变灰，这个方法底层最终调用的方法跟removeDynamicShortcuts一样void disableShortcuts(@NonNull List shortcutIds); 使拖到launcher的图标可用。 静态添加的快捷方式不能使用该方法，使用会报错void enableShortcuts(@NonNull List shortcutIds); 更新快捷方式，例如图标、标题boolean updateShortcuts(List shortcutInfoList); 显示的顺序问题：添加在前的显示在下方，后面添加的显示在上面。 这个类的使用还是比较简单的。添加了这项功能的APP，长按的效果跟iOS的3D touch差不多的视觉体验。 最后附上官网地址：https://developer.android.google.cn/reference/android/content/pm/ShortcutManager.html","tags":[{"name":"开发","slug":"开发","permalink":"https://daynearby.github.io/tags/开发/"}]},{"title":"Android Gallery2 修改双击、手势放大的最大倍数","date":"2017-08-08T07:31:12.000Z","path":"2017/08/08/dev-android-n-gallery2-scale/","text":"Gallery2，android原生的图库，图库中图片缩放有两种方式：1.双击放大，2.双指手势放大。下面说一下修改这里的最大放大倍数。这里修改放大倍数为3倍，照片放到最大后的伸缩范围0.5。 分开两种情况：截图和照片。这两种是不同的缩放倍数，需要两个都进行修改。 截图packages/apps/Gallery2/src/com/android/gallery3d/ui/PhotoView.java 123456789101112131415161718192021222324252627282930public class PhotoView extends GLView implements PlayEngine.OnFrameAvailableListener &#123; //省略代码 @Override public boolean onDoubleTap(float x, float y) &#123; if (mIgnoreScalingGesture) return true; if (mIgnoreSwipingGesture) return true; if (mPictures.get(0).isCamera()) return false; PositionController controller = mPositionController; float scale = controller.getImageScale(); // onDoubleTap happened on the second ACTION_DOWN. // We need to ignore the next UP event. mIgnoreUpEvent = true; if (scale &lt;= .75f || controller.isAtMinimalScale()) &#123; /// M: [BUG.MODIFY] A black area show at the right side of picture.@&#123; /* controller.zoomIn(x, y, Math.max(1.0f, scale * 1.5f)); */ //modified by xx start //1.5最小放大倍数为1.5倍 //scale * 1.5 这是当前获取到，按照大约是1.5倍进行放大，scale的值接近1。4.0f限制的最大放大倍数。 //controller.zoomIn(x, y, Math.max(1.5f, Math.min(scale * 1.5f, 4.0f))); //这里修改为最大放大倍数为3倍，双击、手势都是3倍。 controller.zoomIn(x, y, Math.max(1.5f, Math.min(scale * 3f, 3.0f))); //modified by xx end /// @&#125; &#125; else &#123; controller.resetToFullView(); &#125; return true; &#125; &#125;&#125; 照片照片的需要修改两个地方，一个是配置最大的放大倍数，另外一个是放大到了最大倍数的数据，手势进行再放大的时候，有一个伸缩的范围，放开，就恢复成最大放大倍数。packages/apps/Gallery2/src/com/android/gallery3d/ui/PositionController.java1234567891011121314public class PositionController &#123; // We try to scale up the image to fill the screen. But in order not to // scale too much for small icons, we limit the max up-scaling factor here. private static final float SCALE_LIMIT = 3;//最大放大倍数的配置，设置为3倍 private float getMaximalScale(Box b) &#123; if (mFilmMode) return getMinimalScale(b); if (mConstrained &amp;&amp; !mConstrainedFrame.isEmpty()) return getMinimalScale(b); return 0.5f;//配置放大最大倍数后，手势再拉伸的放大倍数，倍数为0.5 &#125;&#125; 就修改上面三个地方就可以了，由于之前在网上找不到具体的修改方式，这一部分也是刚刚接触，看以前的人修改，修改了很多个地方，都不知道哪个是哪个，都不知道是不是瞎改…跟着瞎改是一件很难受的事，所以还是先理清，再进行准确的修改，这个也便于自己的提升吧。谢谢。","tags":[{"name":"开发","slug":"开发","permalink":"https://daynearby.github.io/tags/开发/"}]},{"title":"Android 7.0 亮度自动模式下：手动调节亮度与显示当前亮度值","date":"2017-06-27T07:04:42.000Z","path":"2017/06/27/dev-android-n-auto-brightness/","text":"根据需求，需要对当前的自动模式的逻辑进行更改，先描述一下具体需求：在自动调节模式下： 当光线发生变化的时候，需要在seekBar显示当前的亮度值 自动模式还可以通过手动调整，并且调整之后当前亮度可以保持，不会立即被自动调节覆盖。 对比机上SeekBar对应当前亮度有变化过程，也就是缓慢增加或者减少。 了解清楚需求后，那么需要先了解当前的逻辑的实现，再对当前的逻辑进行修改，否则就会存在各种未考虑的问题，了解当前的逻辑后根据具体需求，整理出需要修改的问题点，一个一个地解决，保证每个步骤的可行性，那么最后的集成就不会有什么明显的错误存在。 android系统默认的自动模式的逻辑。需要了解这一块需要先找个巨人的肩膀站一下，例如： Android屏幕亮度调节 通过该博客可以完全了解到当前的自动模式的调节逻辑，先不说自动模式当前亮度值的计算，当前亮度的计算需要从另外的blog中进行了解，毕竟计算方法直接看代码比较难懂，可以去找找，之前看的一篇blog，找不到地址了。 那么对自动模式的逻辑进行简单描述一下吧，这样就比较容易理解。 在切换调节模式的时候，配置光线传感器，开始工作，开始采集需要的数据。 采集到足够的数量的数据，通过系列的计算，根据光照值与亮度的表，取出光照值对应的屏幕亮度。 在计算出当前亮度之后，通过回调，更新当前亮度，并且更新电池计算、屏保亮度等信息。 在自动模式下，显示亮度是：当前亮度与权重的运算的值，具体怎么运算，我没看怎么懂，在通知栏中亮度的SeekBar对应的值是权重，滑动SeekBar实现当前亮度值进行微调,微调值adj的范围是[-1,1],在实际使用中是：(adj + 1）/2。所以在原生的逻辑中，是不能直接获取当前亮度、改变当前亮度值，改变亮度还可以通过上面提到的权重。 需求：修改自动模式的亮度显示本来是打算在算法上进行动手的，事实上，对该算法不熟悉，并不能进行有效、安全的修改，那么只能往上走了，通过修改最终计算出亮度的回调，实现保存当前的亮度值、修改当前的亮度值，权重则为默认值，不进行修改。 下面有一个简单的流程图，是我们修改的目标，前提是：亮度调节处于自动模式，简单描述涉及到的关键点，并不全面。 紧接着从两个层次来分解，上层：当前亮度的显示，下一层逻辑：亮度的调节，开始实现步骤： 当前亮度的显示：前提条件是：亮度调节模式是自动模式。a）在数据库添加一个字段：screen_auto_brightness，保存自动模式下的当前亮度值。b）通知栏的SeekBar滑动回调：手动改变，将当前的值传递到亮度调节的逻辑中，并且保存到数据库中。c）在亮度自动改变的情况下：当前光照值改变，触发计算出新的亮度，更新到数据库中，通过ContentObserver实现实时更新当前亮度值。d) 在亮度自动改变的情况下：得到的亮度值是最终的亮度值，中间没有变化过程，SeekBar需要添加一个缓慢变化过程，通过Handler实现以1为单位的渐变过程。 SystemUI中处理当前亮度的逻辑，就是显示当前刻度。1）处理SeekBar显示，以及变化效果。frameworks/base/packages/SystemUI/src/com/android/systemui/settings/BrightnessController.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174public class BrightnessController implements ToggleSlider.Listener &#123; //add by yangfujin@wind-mobi.com in 2017-06-21 for feature 167590 start /** * 更新SeekBar的最大值 * &#123;@link android.provider.Settings.System#SCREEN_AUTO_BRIGHTNESS&#125; uses the range [0, 255]. * Using this factor, it is converted to [0, BRIGHTNESS_ADJ_RESOLUTION] for the SeekBar. */ private static final float BRIGHTNESS_ADJ_RESOLUTION = 255;//default value 2048 ··· private boolean autoChange = false;//区分自动模式下，手动改变还是自动改变的标识 private static final int MSG_CHANGE_BRIGHTNESS = 100;//update slider private static final long DELAY_CHANGE = 30;//update slider 30ms //添加这个Handler为了实现SeekBar进度缓慢变化过程，而不像原生逻辑，直接跳跃一大段，亮度直接变得很亮 private Handler brightnessHandler =new Handler() &#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); if(msg.obj instanceof Integer)&#123; int brigness = (int)msg.obj; if(mControl.getValue() != brigness)&#123; //mControl.getValue()获取当前SeekBar当前刻度，比较目标值和当前刻度，若目标值比当前大，那么就缓慢增加，反之。 final int newBrigness = mControl.getValue() - brigness &gt; 0 ? (mControl.getValue() -1 ) : (mControl.getValue() + 1 ); //update slide mControl.setValue(newBrigness); //再次发送延时消息，实现一点点增加或者减少 brightnessHandler.removeMessages(MSG_CHANGE_BRIGHTNESS); Message msgUpdate = brightnessHandler.obtainMessage(MSG_CHANGE_BRIGHTNESS,brigness); brightnessHandler.sendMessageDelayed(msgUpdate,DELAY_CHANGE); &#125; else &#123; //当前值与目标值相等，更新标识，完成此次更新 autoChange = false; &#125; &#125; &#125; &#125;; //add by yangfujin@wind-mobi.com in 2017-06-21 for feature 167590 end /** ContentObserver to watch brightness **/ private class BrightnessObserver extends ContentObserver &#123; ··· private final Uri BRIGHTNESS_ADJ_URI = Settings.System.getUriFor(Settings.System.SCREEN_AUTO_BRIGHTNESS_ADJ); //add by yangfujin@wind-mobi.com in 2017-06-21 for feature 167590 start //获取新添加的字段的URI，作为实时监听值的变化 private final Uri SCREEN_AUTO_BRIGHTNESS_URI = Settings.System.getUriFor(Settings.System.SCREEN_AUTO_BRIGHTNESS); //add by yangfujin@wind-mobi.com in 2017-06-21 for feature 167590 end //监听到对应字段的值发生改变，理应更新对应的状态 @Override public void onChange(boolean selfChange, Uri uri) &#123; ··· &#125; else if (BRIGHTNESS_ADJ_URI.equals(uri) &amp;&amp; mAutomatic) &#123; updateSlider(); //add by yangfujin@wind-mobi.com in 2017-06-21 for feature 167590 start //数据改变，进行更新显示的数据 &#125;else if (SCREEN_AUTO_BRIGHTNESS_URI.equals(uri) &amp;&amp; mAutomatic) &#123; autoChange = true;//为了区分是自动模式当前亮度改变的标识 updateSlider();//更新SeekBar当前进度 //add by yangfujin@wind-mobi.com in 2017-06-21 for feature 167590 end &#125;else &#123; updateMode(); updateSlider(); &#125; ··· &#125; public void startObserving() &#123; ··· cr.registerContentObserver( BRIGHTNESS_ADJ_URI, false, this, UserHandle.USER_ALL); //add by yangfujin@wind-mobi.com in 2017-06-21 for feature 167590 start //开始监听对应的URI cr.registerContentObserver( SCREEN_AUTO_BRIGHTNESS_URI, false, this, UserHandle.USER_ALL); //add by yangfujin@wind-mobi.com in 2017-06-21 for feature 167590 end &#125; public void stopObserving() &#123; final ContentResolver cr = mContext.getContentResolver(); cr.unregisterContentObserver(this); &#125; &#125;@Overridepublic void onChanged(ToggleSlider view, boolean tracking, boolean automatic, int value, boolean stopTracking) &#123; if (!mAutomatic) &#123; ··· &#125; else &#123; //modified by yangfujin@wind-mobi.com in 2017-06-21 for feature 167590 start //移除原来的逻辑 //final float adj = value / (BRIGHTNESS_ADJ_RESOLUTION / 2f) - 1; if(autoChange) return; //modified by yangfujin@wind-mobi.com in 2017-06-21 for feature 167590 end if (stopTracking) &#123; MetricsLogger.action(mContext, MetricsEvent.ACTION_BRIGHTNESS_AUTO, value); &#125; //modified by yangfujin@wind-mobi.com in 2017-06-21 for feature 167590 start setBrigness(value);//添加新的逻辑，也就是将当前值传到亮度调节的逻辑中 /*setBrightnessAdj(adj);*/ //移除原来的逻辑 //modified by yangfujin@wind-mobi.com in 2017-06-21 for feature 167590 end if (!tracking) &#123; AsyncTask.execute(new Runnable() &#123; public void run() &#123; //modified by yangfujin@wind-mobi.com in 2017-06-21 for feature 167590 start //replace SCREEN_AUTO_BRIGHTNESS_ADJ by SCREEN_AUTO_BRIGHTNESS //自动模式，手动调节亮度，保存当前亮度值到数据库中 Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_AUTO_BRIGHTNESS, value, UserHandle.USER_CURRENT); //modified by yangfujin@wind-mobi.com in 2017-06-21 for feature 167590 end &#125; &#125;); &#125; &#125; ··· &#125; /** * 将当前亮度值传到调节当前亮度的逻辑中 * add by yangfujin@wind-mobi.com in 2017-06-21 for feature 167590 start * add for auto-brightness manual change */ private void setBrigness(int brightness) &#123; try &#123; mPower.setTemporaryScreenAutoBrightnessSettingOverride(brightness); &#125; catch (RemoteException ex) &#123; Log.e(TAG,\"in auto-brightness setBrigness failed ,Error \"+ex); &#125; &#125; //add by yangfujin@wind-mobi.com in 2017-06-21 for feature 167590 end /** Fetch the brightness from the system settings and update the slider */ private void updateSlider() &#123; if (mAutomatic) &#123;//当前为自动模式 //modified by yangfujin@wind-mobi.com in 2017-06-21 for feature 167590 start /* 移除原来的逻辑 float value = Settings.System.getFloatForUser(mContext.getContentResolver(), Settings.System.SCREEN_AUTO_BRIGHTNESS_ADJ, 0, UserHandle.USER_CURRENT); mControl.setMax((int) BRIGHTNESS_ADJ_RESOLUTION); mControl.setValue((int) ((value + 1) * BRIGHTNESS_ADJ_RESOLUTION / 2f)); */ //获取当前亮度 int value = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_AUTO_BRIGHTNESS, 0, UserHandle.USER_CURRENT); mControl.setMax((int) BRIGHTNESS_ADJ_RESOLUTION);//更新最大值 if(autoChange)&#123;//是否是自动模式下改变当前亮度值 //这里为了实现seekBar一点点增加的效果，亮度变化过程需要一个小变化率 brightnessHandler.removeMessages(MSG_CHANGE_BRIGHTNESS); Message msg = brightnessHandler.obtainMessage(MSG_CHANGE_BRIGHTNESS,value); brightnessHandler.sendMessageDelayed(msg,DELAY_CHANGE); &#125; else &#123; //直接更新当前进度 mControl.setValue(value); &#125; //modified by yangfujin@wind-mobi.com in 2017-06-21 for feature 167590 end &#125; else &#123; ··· &#125; &#125; ····&#125; 2）需要添加获取SeekBar当前值的方法。frameworks/base/packages/SystemUI/src/com/android/systemui/settings/ToggleSlider.java123456789public class ToggleSlider extends RelativeLayout &#123; ··· //add by yangfujin@wind-mobi.com in 2017-06-21 for feature 167590 start public int getValue()&#123; return mSlider.getProgress(); &#125; //add by yangfujin@wind-mobi.com in 2017-06-21 for feature 167590 end ···&#125; 亮度的调节：a）从SystemUI传递到services，原来的逻辑使用的是跨进程通信，那么我们也在直接添加一个方法，不对原来的逻辑进行修改。b）自动模式下，存储当前亮度值，数据库添加一个字段，在system表中。下面开始具体的步骤： 1）传值是通过一个对象的形式进行传递，那么这里在这个类中添加两个字段。frameworks/base/core/java/android/hardware/display/DisplayManagerInternal.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public abstract class DisplayManagerInternal &#123; ··· //add by yangfujin@wind-mobi.com in 2017-06-21 for feature 167590 /** * The desired screen brightness in the range 0 (minimum / off) to 255 (brightest). * current brightness when auto-brightness enable */ public int autoModeScreenBrightness；//当前亮度值 /** * The desired screen brightness when auto-brightness enable,change by user &#123;true&#125;,other &#123;false&#125; */ public boolean autoModeManualOp;//作为手动改变亮度的标识 //add by yangfujin@wind-mobi.com in 2017-06-21 for feature 167590 end ··· //下面需要完善这个类中的其他方法 public DisplayPowerRequest() &#123; ··· dozeScreenState = Display.STATE_UNKNOWN; //add by yangfujin@wind-mobi.com in 2017-06-21 for feature 167590 start autoModeScreenBrightness = PowerManager.BRIGHTNESS_ON; autoModeManualOp = false; //add by yangfujin@wind-mobi.com in 2017-06-21 for feature 167590 end &#125; ··· public void copyFrom(DisplayPowerRequest other) &#123; ··· useTwilight = other.useTwilight; //add by yangfujin@wind-mobi.com in 2017-06-21 for feature 167590 start autoModeScreenBrightness = other.autoModeScreenBrightness; autoModeManualOp = other.autoModeManualOp; //add by yangfujin@wind-mobi.com in 2017-06-21 for feature 167590 end &#125; public boolean equals(DisplayPowerRequest other) &#123; return other != null ··· &amp;&amp; useTwilight == other.useTwilight //add by yangfujin@wind-mobi.com in 2017-06-21 for feature 167590 start &amp;&amp; autoModeScreenBrightness == other.autoModeScreenBrightness &amp;&amp; autoModeManualOp == other.autoModeManualOp; //add by yangfujin@wind-mobi.com in 2017-06-21 for feature 167590 end &#125; @Override public String toString() &#123; return \"policy=\" + policyToString(policy) ··· + \", useTwilight=\" + useTwilight //add by yangfujin@wind-mobi.com in 2017-06-21 for feature 167590 start + \",autoModeScreenBrightness=\"+autoModeScreenBrightness +\",autoModeManualOp=\"+autoModeManualOp; //add by yangfujin@wind-mobi.com in 2017-06-21 for feature 167590 end &#125; ···&#125; 2）添加一个传递值的方法frameworks/base/core/java/android/os/IPowerManager.aidl12345678interface IPowerManager&#123; ··· //添加方法，上层向service传值，传递自动模式当前亮度值 //add by yangfujin@wind-mobi.com in 2017-06-21 for feature 167590 start void setTemporaryScreenAutoBrightnessSettingOverride(int brightness); //add by yangfujin@wind-mobi.com in 2017-06-21 for feature 167590 end ···&#125; 3）覆写上面添加的方法frameworks/base/services/core/java/com/android/server/power/PowerManagerService.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public final class PowerManagerService extends SystemService implements Watchdog.Monitor &#123; ··· //add by yangfujin@wind-mobi.com in 2017-06-21 for feature 167590 //添加临时值，作为保存SystemUI传下来的值 // The screen brightness adjustment setting override from the settings // application to temporarily adjust the auto-brightness adjustment factor //in the rang 0 .. 255 // Use NaN to disable. private int mTemporaryScreenAutoBrightnessSettingOverride = -1; ··· private boolean updateDisplayPowerStateLocked(int dirty) &#123; ··· mDisplayPowerRequest.lowPowerMode = mLowPowerModeEnabled; mDisplayPowerRequest.boostScreenBrightness = mScreenBrightnessBoostInProgress; mDisplayPowerRequest.useTwilight = mBrightnessUseTwilight; //add by yangfujin@wind-mobi.com in 2017-06-21 for feature 167590 start mDisplayPowerRequest.autoModeManualOp = false;//调用这个方法的都不是手动改变的，手动改变的亮度的是另外一个方法 //add by yangfujin@wind-mobi.com in 2017-06-21 for feature 167590 end &#125; /** * 自动模式，手动调节执行的方法 * add by yangfujin@wind-mobi.com in 2017-06-21 for feature 167590 * change backlight by user when in auto-brightness,rang 0..255 * @param brightness The overridden brightness. */ private void setTemporaryScreenAutoBrightnessSettingOverrideInternal(int brightness) &#123; synchronized (mLock) &#123; // Note: This condition handles NaN because NaN is not equal to any other // value, including itself. if (mTemporaryScreenAutoBrightnessSettingOverride != brightness) &#123; mTemporaryScreenAutoBrightnessSettingOverride = brightness; //验证传过来的亮度值是否是有效的 if(!isValidBrightness(mTemporaryScreenAutoBrightnessSettingOverride))&#123; mTemporaryScreenAutoBrightnessSettingOverride = mScreenBrightnessSetting; &#125; //更新亮度值 mDisplayPowerRequest.autoModeScreenBrightness = mTemporaryScreenAutoBrightnessSettingOverride; //上层只有自动模式下才会调用这个，下面两个值写死 mDisplayPowerRequest.useAutoBrightness = true;//当前模式：自动模式 mDisplayPowerRequest.autoModeManualOp = true;//自动模式下，手动改变 //update brightness mDisplayReady = mDisplayManagerInternal.requestPowerState(mDisplayPowerRequest, mRequestWaitForNegativeProximity);//传递该对象，更新亮度 &#125; &#125; &#125; /** * 覆写AIDL中的方法 * add by yangfujin@wind-mobi.com in 2017-06-21 for feature 167590 * Used by the settings application and brightness control widgets to * temporarily override the current screen auto-brightness brightness setting so that the * user can observe the effect of an intended settings change without applying * it immediately. * * The override will be canceled when the setting value is next updated. * * @param adj The overridden brightness, or Float.NaN to disable the override. * * @see android.provider.Settings.System#SCREEN_AUTO_BRIGHTNESS */ @Override // Binder call public void setTemporaryScreenAutoBrightnessSettingOverride(int brightness)&#123; mContext.enforceCallingOrSelfPermission( android.Manifest.permission.DEVICE_POWER, null); final long ident = Binder.clearCallingIdentity(); try &#123; setTemporaryScreenAutoBrightnessSettingOverrideInternal(brightness); &#125; finally &#123; Binder.restoreCallingIdentity(ident); &#125; &#125; 4）数据库中添加一个字段frameworks/base/core/java/android/provider/Settings.java123456789101112131415public final class Settings &#123; ··· public static final class System extends NameValueTable &#123; ··· //add by yangfujin@wind-mobi.com in 2017-06-21 for feature 167590 start /** * in auto-brightness mode,user change current backbrightness * rang 0..255 * @hide */ public static final String SCREEN_AUTO_BRIGHTNESS = \"screen_auto_brightness\"; //add by yangfujin@wind-mobi.com in 2017-06-21 for feature 167590 end ··· &#125; &#125; 5）更新亮度。frameworks/base/services/core/java/com/android/server/display/DisplayPowerController.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485final class DisplayPowerController implements AutomaticBrightnessController.Callbacks &#123; ··· //add by yangfujin@wind-mobi.com in 2017-06-21 for feature 167590 start //for manial change brightness,shuold delay for auto change private boolean shouldDelay ;//作为手动改变亮度后的标识 private static final int MSG_AUTO_MODE_MANUAL_CHANGE = 201; private static final long MSG_DELAY_DURATION = 3 * 1000L;//3s延时，意思是：当手动改变之后，3s内不接受光线传感器接收值变化引起亮度的改变，这样可以实现在当前光线环境下，保持手动调节的亮度 //add by yangfujin@wind-mobi.com in 2017-06-21 for feature 167590 end ··· private void updatePowerState() &#123; ··· if (mPowerRequest.boostScreenBrightness &amp;&amp; brightness != PowerManager.BRIGHTNESS_OFF) &#123; brightness = PowerManager.BRIGHTNESS_ON; &#125; // Apply auto-brightness. boolean slowChange = false; //add by yangfujin@wind-mobi.com in 2017-06-21 for feature 167590 start //标识：自动模式下，改变亮度应该使用小速率，慢慢变化，配合SeekBar缓慢滑动 boolean isManualChange = false;//for brigness change rate //add by yangfujin@wind-mobi.com in 2017-06-21 for feature 167590 end if (brightness &lt; 0) &#123; if (autoBrightnessEnabled) &#123; //modified by yangfujin@wind-mobi.com in 2017-06-21 for feature 167590 start if(mPowerRequest.autoModeManualOp) &#123;//手动调节下 brightness = mPowerRequest.autoModeScreenBrightness;//上层SystemUI传递下来的亮度值 shouldDelay = true;//手动改变，那么应该3s内不接受光线传感器光线变化的回调 isManualChange = true;//应该时候小速率，实现与SeekBar同步，亮度与SeekBar速率的配合 mHandler.removeMessages(MSG_AUTO_MODE_MANUAL_CHANGE);//3s后改变shouldDelay值 mHandler.sendEmptyMessageDelayed(MSG_AUTO_MODE_MANUAL_CHANGE,MSG_DELAY_DURATION); &#125; else &#123; isManualChange = false; if(!shouldDelay)&#123;//没有手动调节过，立马接收光感的变化引起的亮度变化；若调节过，则需要等3s，shouldDelay =false brightness = mAutomaticBrightnessController.getAutomaticScreenBrightness(); Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_AUTO_BRIGHTNESS, brightness, UserHandle.USER_CURRENT); &#125;else&#123;//在手动调节过，3s内还是显示手动调节的亮度，这里会有回调因为屏保、电池相关状态更新 brightness = mPowerRequest.autoModeScreenBrightness; &#125; &#125; //modified by yangfujin@wind-mobi.com in 2017-06-21 for feature 167590 end &#125; if (brightness &gt;= 0) &#123; // Use current auto-brightness value and slowly adjust to changes. brightness = clampScreenBrightness(brightness); //modified by yangfujin@wind-mobi.com in 2017-06-21 for feature 167590 start // add isManualChange，为了低速率改变亮度 if (mAppliedAutoBrightness &amp;&amp; !autoBrightnessAdjustmentChanged &amp;&amp; !isManualChange) &#123; slowChange = true; // slowly adapt to auto-brightness &#125; //modified by yangfujin@wind-mobi.com in 2017-06-21 for feature 167590 end mAppliedAutoBrightness = true; &#125; else &#123; mAppliedAutoBrightness = false; &#125; &#125; else &#123; mAppliedAutoBrightness = false; &#125; &#125; ··· private final class DisplayControllerHandler extends Handler &#123; public DisplayControllerHandler(Looper looper) &#123; super(looper, null, true /*async*/); &#125; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; ··· case MSG_PROTECT_LOW_DIMMING: handleProtectLowDimming(); break; //add by by yangfujin@wind-mobi.com in 2017-06-21 for feature 167590 start case MSG_AUTO_MODE_MANUAL_CHANGE: //3s更新该值，为了防止抖动，刚手动调节完，环境光改变这么巧引起背光变化，那就会有很明显的闪烁 shouldDelay = false; break; //add by yangfujin@wind-mobi.com in 2017-06-21 for feature 167590 end &#125; &#125; &#125;&#125; 总结 这里是通过修改自动模式的上层代码，实现手动调节当前亮度，而不是调节权重值，并且可以显示当前亮度，对原来的逻辑不进行大的修改，只是增加了一些小的方法块。亮度调节这块的逻辑比较复杂，涉及到的情况比较多，所以修改起来比较难，需要耐心读懂这部分的逻辑，若修改有问题，可能会导致屏幕闪烁，或者屏幕亮度被调到到最亮或最暗，还有自动模式下，手动调节亮度闪烁，这是我踩过的坑。","tags":[{"name":"开发","slug":"开发","permalink":"https://daynearby.github.io/tags/开发/"}]},{"title":"Android USB默认连接模式为MTP","date":"2017-06-13T11:41:10.000Z","path":"2017/06/13/dev-android-n-usb-mode/","text":"很多时候，手机项目开发，客户都要求配置USB的默认连接方式，但是在Android 6.0以及之后的版本就直接配置USB连接模式，看到的USB连接模式还是仅充电，而这是google的默认设计。那么对于这个问题，也看了很多网上的一些解法，如：Android 5.0可以直接配置默认值，6.0就不可行了。另外，还有在USB连接的时候进行设置，当连接之后就执行一次设置USB连接模式，将MTP设置为当前连接模式，这样的做法在7.0上面也是可以的。事实上，当仅充电的时候，查看当前USB模式的配置，就算是mtp，但是还是没有显示SD卡和内部存储器，主要是一个标志的问题。 现有的一种解法那么这里先说一下在连接USB的情况下，执行一次USB连接模式的设置，这里有一位大牛的方法，并且提到Android 6.0以前的做法，Android 6.0 USB连接模式默认选为MTP ，大家去参考学习一下，那么我说一下这位大牛的改法，在Android 6.0和7.0上面的表现的不同一个的地方： Android版本 在锁屏的情况下 在解锁的情况下 6.0 仅充电 MTP 7.0 MTP MTP 我们的测试就提了一个不安全的bug，没有解锁就能直接访问SD卡、内部存储器的数据，这是不安全的。那好像也说得有道理，那么就改。但是这个可能又时候某些公司的客户需求。 公司6.0的解法对于上面的解法不怎么像6.0的行为，接着我就去看了一下，我们公司以前Android 6.0是怎么修改的，是直接修改了值，将这个值修改后，就能显示SD卡、内部存储器了。修改文件frameworks/base/services/usb/java/com/android/server/usb/UsbDeviceManager.java。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class UsbDeviceManager &#123; ···省略很多代码··· private boolean mConfigured; //modified in 2017-05-22 start //解锁数据，连接电脑，就能看到默认连接模式为MTP private boolean mUsbDataUnlocked = true; //modified in 2017-05-22 end private String mCurrentFunctions; private String mDefaultFunctions; ······ @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case MSG_UPDATE_STATE: mConnected = (msg.arg1 == 1); mConfigured = (msg.arg2 == 1); mUsbConfigured = mConfigured; if (!mConnected) &#123; //modified in 2017-05-22 start //default usb connect mode as mtp // When a disconnect occurs, relock access to sensitive user data //断开连接的时候，保持当前连接模式，下次连接的时候还是MTP mUsbDataUnlocked = true; //modified in 2017-05-22 end &#125; updateUsbNotification(); updateAdbNotification(); if (UsbManager.containsFunction(mCurrentFunctions, UsbManager.USB_FUNCTION_ACCESSORY)) &#123; updateCurrentAccessory(); &#125; else if (!mConnected) &#123; //modified in 2017-05-22 start //change default usb connect mode as mtp,do not restore // 这里不恢复默认连接方式，保持保持当前的连接模式 setEnabledFunctions(null, true); //modified in 2017-05-22 end &#125; if (mBootCompleted) &#123; updateUsbStateBroadcastIfNeeded(); updateUsbFunctions(); &#125; ······ &#125; 上面的这种修改方式比较简单，在android6.0和7.0上都是可以的，但是还是有差异： Android版本 在锁屏的情况下 在解锁的情况下 6.0 仅充电 MTP 7.0 MTP MTP 这中修改方式的最终结果还是跟上面那位大牛的修改方式表现结果一致。那么应该说是Google在7.0上又修改了这一部分的代码，使用公司以前6.0的改法，还是不行。 现在Android 7.0的解法但是还是对不上公司测试提的问题，那还是需要接续修改。那就仔细看看这类，再上网了解一下USB连接模式这块，这一块还是很深的…，设计硬件的，都是稍微复杂一点，还要跟底层通信什么的，有一点大概的了解之后，再回来解决一下这个问题，那么从切换USB连接模式的上层实现，那么就是修改mUsbDataUnlocked的值，应该说是适当的时候修改mUsbDataUnlocked的值，那么下面分析一下有几种情况需要改变： 手机是锁屏情况下连接USB，连接模式是仅充电。 手机是解锁的情况下连接USB，连接模式是MTP。 手机熄屏的情况下断开USB，连接方式要更新为仅充电。 手机解锁的情况下断开USB，连接方式要更新为仅充电。 应该就是这四种情况，那么主要的问题是： 用户解锁了，通过主测广播：Intent.ACTION_USER_PRESENT判断是否解锁后用户到前台。 USB连接状态有对应的回调，并且这个时候更新USB连接模式。 熄屏了，通过注册广播Intent.ACTION_SCREEN_OFF判断，还需要注册广播Intent.ACTION_SCREEN_ON，作为屏幕状态值的切换。 在UsbService.java类中注册以上说到的广播接收者，再对UsbDeviceManager.java类中的标识进行更新。 修改frameworks/base/services/usb/java/com/android/server/usb/UsbService.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class UsbService extends IUsbManager.Stub &#123; ······ final IntentFilter filter = new IntentFilter(); filter.setPriority(IntentFilter.SYSTEM_HIGH_PRIORITY); filter.addAction(Intent.ACTION_USER_SWITCHED); filter.addAction(Intent.ACTION_USER_STOPPED); //add by xx in 2017-06-12 for bug 169853 start //注册三个广播 filter.addAction(Intent.ACTION_USER_PRESENT); filter.addAction(Intent.ACTION_SCREEN_OFF); filter.addAction(Intent.ACTION_SCREEN_ON); //add by xx in 2017-06-12 for bug 169853 end filter.addAction(DevicePolicyManager.ACTION_DEVICE_POLICY_MANAGER_STATE_CHANGED); mContext.registerReceiver(mReceiver, filter, null, null); ······ private BroadcastReceiver mReceiver = new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; final int userId = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, -1); final String action = intent.getAction(); if (Intent.ACTION_USER_SWITCHED.equals(action)) &#123; setCurrentUser(userId); &#125; else if (Intent.ACTION_USER_STOPPED.equals(action)) &#123; synchronized (mLock) &#123; mSettingsByUser.remove(userId); &#125; &#125; else if (DevicePolicyManager.ACTION_DEVICE_POLICY_MANAGER_STATE_CHANGED .equals(action)) &#123; if (mDeviceManager != null) &#123; mDeviceManager.updateUserRestrictions(); &#125; //add by xx in 2017-06-12 for bug 169853 start //处理三个广播 &#125;else if (Intent.ACTION_USER_PRESENT.equals(action)) &#123; if (mDeviceManager != null) &#123; mDeviceManager.usbDataUnlocked(true);//这个方法系统有的 mDeviceManager.setUserPresent();//这个方法是添加的 &#125; &#125; else if (Intent.ACTION_SCREEN_OFF.equals(action)) &#123; if (mDeviceManager != null) &#123; mDeviceManager.updateScreentSate(true);//这个方法是添加的，为了更新屏幕状态 &#125; &#125; else if (Intent.ACTION_SCREEN_ON.equals(action)) &#123; if (mDeviceManager != null) &#123; mDeviceManager.updateScreentSate(false);//这个方法是添加的，为了更新屏幕状态 &#125; //add by xx in 2017-06-12 for bug 169853 end &#125; &#125; &#125;;&#125; 接下来修改frameworks/base/services/usb/java/com/android/server/usb/UsbDeviceManager.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125public class UsbDeviceManager &#123; ····· //添加两个全局变量，作为标识 //modified by xx in 2017-06-12 for bug 169853 start private boolean mUserPresent = false;//用户是否结果到前台 private boolean screenOff = false;//屏幕是否是熄屏 private boolean changeByUser = false;//切换USB模式的时候，是这里代码切换的，还是用户点击切换的。 //modified by xx in 2017-06-12 for bug 169853 end ····· //添加这两个方法，在UsbService.java中用到，更新这边的状态 //modified by xx in 2017-06-12 for bug 169853 start public void setUserPresent()&#123; mUserPresent = true; &#125; public void updateScreentSate(boolean state)&#123; screenOff = state; if(!screenOff) &#123; mUserPresent = false; &#125; if(mHandler != null)&#123; mHandler.updateUsbMode(); &#125; &#125; public void usbDataUnlocked()&#123; changeByUser = false; mHandler.sendMessage(MSG_SET_USB_DATA_UNLOCKED, true); &#125; //modified by xx in 2017-06-12 for bug 169853 end ····· //更新USB连接状态 public void updateState(String state) &#123; int connected, configured; if (\"HWDISCONNECTED\".equals(state)) &#123; connected = 0; configured = 0; mHwDisconnected = true; //add by xx in 2017-08-03 for swtich usb mode start changeByUser = false; //add by xx in 2017-08-03 for swtich usb mode end &#125; else if (\"DISCONNECTED\".equals(state)) &#123; connected = 0; configured = 0; mHwDisconnected = false; //modified by xx in 2017-06-12 for bug 169853 start //当熄屏的情况下，更新用户不在前台的标识 if(screenOff)&#123; mUserPresent = false; &#125; //modified by xxx in 2017-06-12 for bug 169853 end &#125; else if (\"CONNECTED\".equals(state)) &#123; connected = 1; configured = 0; ····· private final class UsbHandler extends Handler &#123; ····· //在收到更新USB状态的消息之后，更新USB模式，当然要根据用户是否在前台进行判断 @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case MSG_UPDATE_STATE: mConnected = (msg.arg1 == 1); mConfigured = (msg.arg2 == 1); mUsbConfigured = mConfigured; //modified by xx in 2017-06-12 for bug 169853 start //update usb state first updateUsbMode(); if (mUserPresent &amp;&amp; !changeByUser) &#123; //用户在前台的 mUsbDataUnlocked = true;//解锁数据，那么连接电脑就能看到连接模式为MTP了 &#125; //modified by xx in 2017-06-12 for bug 169853 end if (!mConnected) &#123; // When a disconnect occurs, relock access to sensitive user data mUsbDataUnlocked = false; &#125; updateUsbNotification(); updateAdbNotification(); if (UsbManager.containsFunction(mCurrentFunctions, UsbManager.USB_FUNCTION_ACCESSORY)) &#123; updateCurrentAccessory(); &#125; else if (!mConnected) &#123; &#125; ·····//省略代码 case MSG_SET_USB_DATA_UNLOCKED: //add by xx in 2017-08-03 for swtich usb mode start if(!changeByUser &amp;&amp; mUsbDataUnlocked) return; //add by xx in 2017-08-03 for swtich usb mode end setUsbDataUnlocked(msg.arg1 == 1); break; &#125; ····· //在UsbHandler类中的方法，主要是因为用到USB状态值：mConnected //add by xx in 2017-06-12 for bug 169853 start private void updateUsbMode()&#123; if(!mConnected &amp;&amp; screenOff)&#123; mUserPresent = false; &#125; &#125; //add by xx in 2017-06-12 for bug 169853 end &#125; ····· &#125; //省略其他代码 public void setCurrentFunctions(String functions) &#123; if (DEBUG) Slog.d(TAG, \"setCurrentFunctions(\" + functions + \")\"); //add by xx in 2017-08-03 for swtich usb mode start changeByUser = true; //add by xx in 2017-08-03 for swtich usb mode end mHandler.sendMessage(MSG_SET_CURRENT_FUNCTIONS, functions); &#125; //省略其他代码&#125; 主要修改上面两个类，实现以下情况： Android版本 在锁屏的情况下 在解锁的情况下 7.0 仅充电 MTP 另外Android 7.1只要persist.sys.usb.config这个属性的值设为mtp，后面不要加上adb那些什么的，就可以了”，说是这样。 那么这样的行为就跟Android 6.0 的表现一样了，问题可以说已经解决了。像这些修改一个默认值的问题还是比较简单的。事实上，对USB完全没有接触，还是要多看，有那么多巨人，就借个肩膀来站站呗，就像本文一开始提到的那位大神一样，在这里表示感谢。","tags":[{"name":"开发","slug":"开发","permalink":"https://daynearby.github.io/tags/开发/"}]},{"title":"先想好再动手","date":"2017-02-25T06:22:32.000Z","path":"2017/02/25/impressions-4-my-initiation/","text":"——说干就干，预想过过程和结果了吗？ 今天跟一个朋友聊另外一个朋友的事情，想起以前的自己。想起以前的一个坏习惯：没想清楚就动手，忙得都感动自己了，但是就拿不出什么成果。那么讲一下这个坏习惯给自己带来的遭遇吧。 从事做软件开发的，我在第一家或者说是第二家公司吧，为什么一开始说是第一家呢，因为在第一家是没有签什么合同的，就是口头协议，在第二家才是有签了具体合同，那这里还是叫第二家吧。 在这第二家公司实习三个月的过程中，完全没有什么人带的感觉，连师傅领进门都没有，应该说是：说干就干，说做什么功能就直接干。 例如：一个界面，做一个列表显示内容，就凭着自己以前学习基础的过程，知道有什么控件可以使用就直接用上了，接着就是显示内容，刷新显示的内容，遇到具体的问题就上google，幸好当时还知道google，解决问题的速度也算是挺快的，基本能搜到类似的问题，有问题可以搜索解决，但是….当方向错了怎么办？用错了控件，发现这个控件并不能满足目标的功能，只是满足一开始的简单需求而已，添加更多一些东西就会有问题，或者是性能并没有那么好，或者是完全没有考虑兼容性问题，那这就糟糕了，前面花的时间就全部都浪费了，那么就只能重新开始做，重新考虑一下应该选择怎样的技术去实现了。 在开始工作的时候遇到很多这样的问题，但是就怪自己不会思考，只考虑：我很快就能做出来了，事与愿违，并没有那么快，很多时候到了差不多的时候，连自己都看不过了，推到重构，前面白花花的时间就浪费了吧 那时候每天都是很忙，就记得很累，手基本没听过的感觉，连自己都感动了，实际上就是完成了基本任务而已，连什么技术总监看我每天提交的代码也没有任何评论，最后离开的时候，他才说：你进来这么久，我也没有给你分配什么具体的任务，也没有指导什么，噼里啪啦，说了挺多的。 想一下这个过程，没想好就开始动手的坏习惯基本其实没有多少收益，但是总结一下还是有的。 第一点，尽量做到学以致用。在那时候我自己的就没有做到学以致用，怎么说呢，学习计算机专业，学习的各种理论，其中有一门课叫做软件工程，没有使用到的就是可行性分析，在实际进行编码之前就又一个可行性分析，只是从写代码方面来说，只是技术可行性，也就是在实际编码之前，先进行技术可行性分析，分析这样是不是可以实现，会遇到怎样的技术问题，或者是从前人的经验来说，这样实施是否可行，还是有更好的办法，这样可以避免盲目开发，浪费时间。 第二点，多点请教别人，没有别人可以请教就上网搜索。“敏而好学，不耻下问” ，以前都看不懂这些词，原来是因为自己年龄还不到，或者更应该说是因为自己的经历还不够，完全参悟不到其中的道理，还是古人是思想大家啊。多请教，就可以站在巨人的肩膀上进行提高，有事半功倍的作用。 第三点，多留自己职业上的习惯，要养成良好的习惯，不要给别人挖坑。对我自己的职业生涯有作用，一开始写代码的时候，就是野路子，虽然之后也没有提高多少，但是开始注意了代码整洁和设计模式。一开始的就自己写代码，编程的人都知道，就写自己一开始想出来的，不管什么代码结构、什么性能，谢了一个星期之后，就想：咦，怎么技术总监一点声音都没有呢？是我代码太烂了，回头看一下，嗯，挺乱的([捂脸])，那就回去整理一下代码，写一些公共类、添加接口，使用观察者、工厂、单例模式什么的，将类按功能分包，基本将原来的结构重构了，幸好是刚开始。 第四点，多与人沟通，多思考。额..在这家公司，其他技术人员不在这边，都不在….所以技术总监也很忙，没用理我？好像说的通。多与人沟通，起到启蒙效果。我自己，从小学到初中，高中再到大学，没有启蒙老师，自己也不知道自己在做什么，同学干嘛就一起，老师要求干嘛就干嘛，家里也对我是放养状态，那..嗯，现在想以前还是挺happy的，哈哈，现在感觉是浪费了很多时间，本来那时候就对编程有兴趣，但是没人对我说可以干嘛，自己也没有那种意识（家在农村，学校也在个小城镇）。那么就说如果，那时候有个启蒙老师，或许那时候无聊的时候久不会在学校闲逛，甚至去网吧玩单机游戏，去网吧玩单机游戏？这里..额。还是怪自己吧，不主动。现在在公司，也尽量跟别人共同交流，学一下别人的思想，毕竟别人都是工作几年的，或多或少都是有见过一些人，处理过一些事，或许这样就会有一点启发作用。对了，现在也是挺菜的。 加油！！","tags":[{"name":"随笔","slug":"随笔","permalink":"https://daynearby.github.io/tags/随笔/"}]},{"title":"Android 7.0 Settings 加载选项","date":"2017-02-13T10:40:35.000Z","path":"2017/02/13/dev-android-settings-n/","text":"先写在前面，这说的Settings加载选项是指Settings这个应用显示在主界面的选项，这个修改需要对系统源码进行修改。 Android 7.0 Settings顶部多了一个建议选项，多了个侧边栏，操作更加便捷了。 Android 6.0之前做Android 6.0开发的，都会了解到6.0的Settings加载选项是通过加载dashboard_categories.xml，获取需要显示的选项，并且在SettingsActivity中也进行判断是否要显示，所以在6.0上添加一个选项是比较简单的，直接在dashboard_categories.xml添加icon、title、summary，也可以添加目标fragment和Intent，这样就可以顺利跳转到对应的界面了。但是在7.0上，google对Settings进行了重构。 Android 7.07.0的Settings的选项不再从dashboard_categories.xml中加载选项列表，而是通过在Androidmanifest.xml中，配置intent-filter的Action，在通过PackageManager进行指定的Action进行搜索，那么就可以获取到需要显示的选项列表了，并且也需要在代码中进行判断，判断哪些功能需要显示与否。TileUtils.java中通过几个Action进行获取系统中对应的activity，如Settings中的几个 1234567891011121314private static final String SETTINGS_ACTION = \"com.android.settings.action.SETTINGS\";private static final String OPERATOR_SETTINGS = \"com.android.settings.OPERATOR_APPLICATION_SETTING\";private static final String OPERATOR_DEFAULT_CATEGORY = \"com.android.settings.category.wireless\";private static final String MANUFACTURER_SETTINGS = \"com.android.settings.MANUFACTURER_APPLICATION_SETTING\";private static final String MANUFACTURER_DEFAULT_CATEGORY = \"com.android.settings.category.device\"; 通过PackageManager进行搜索，获取到这一系列的activity信息，123PackageManager pm = context.getPackageManager();List&lt;ResolveInfo&gt; results = pm.queryIntentActivitiesAsUser(intent, PackageManager.GET_META_DATA, user.getIdentifier()); 并且在AndroidManifest.xml通过meta-data配置了icon、title、summary，那这就有Settings中显示的图标、标题和说明。还有在Settings中显示的分类、目标Fragment。Settings 的AndroidManifest.xml 下面那代码是Settings-&gt;about phone的Activity配置。123456789101112131415161718192021222324252627282930313233343536373839&lt;activity android:name=\"Settings$DeviceInfoSettingsActivity\" android:theme=\"@style/Theme.SubSettingsDialogWhenLarge\" android:label=\"@string/device_info_settings\" android:icon=\"@drawable/ic_settings_about\" android:taskAffinity=\"com.android.settings\" android:parentActivityName=\"Settings\"&gt; &lt;intent-filter android:priority=\"1\"&gt; &lt;action android:name=\"android.settings.DEVICE_INFO_SETTINGS\" /&gt; &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt; &lt;category android:name=\"android.intent.category.VOICE_LAUNCH\" /&gt; &lt;/intent-filter&gt; &lt;!-- a 这个是必须的，在settings通过该过滤器获取该选项--&gt; &lt;intent-filter android:priority=\"-1\"&gt; &lt;action android:name=\"com.android.settings.action.SETTINGS\" /&gt; &lt;/intent-filter&gt; &lt;!-- a --&gt; &lt;!-- b 这个是必须的，在settings显示在哪个分类中，当前是显示在system的这个分类中--&gt; &lt;meta-data android:name=\"com.android.settings.category\" android:value=\"com.android.settings.category.system\" /&gt; &lt;!-- b --&gt; &lt;!-- c 这个也是需要的，显示的标题--&gt; &lt;meta-data android:name=\"com.android.settings.title\" android:resource=\"@string/about_settings\" /&gt; &lt;!-- c --&gt; &lt;!-- d 这个也是需要的，加载的Fragment，如果是遵循settings中的规则，Activity + Fragment的模式--&gt; &lt;meta-data android:name=\"com.android.settings.FRAGMENT_CLASS\" android:value=\"com.android.settings.DeviceInfoSettings\" /&gt; &lt;!-- d --&gt; &lt;meta-data android:name=\"com.android.settings.PRIMARY_PROFILE_CONTROLLED\" android:value=\"true\" /&gt; &lt;/activity&gt; 在SettingsActivity.java的ENTRY_FRAGMENTS中，根据fragment className进行fragment是否有效的判断。12345private static final String[] ENTRY_FRAGMENTS = &#123;...DeviceInfoSettings.class.getName(),...&#125; Settings显示各选项的思路比较简单，所以直接在Settings里面添加功能选项还是比较简单的。 添加第三方apk如果需要Settings中添加打包好的apk，需要三个步骤。 添加action。可以被PackageManager搜索到的activity，搜索到后添加到Settings的选项列表中 12private static final String EXTRA_SETTINGS_ACTION = \"com.android.settings.action.EXTRA_SETTINGS\"; 添加显示的选项信息。在该apk的AndroidManifest.xml对应的启动activity中添加以下meta-data，还有intent-filter。按照类似上面的那种方式，只要在AndroidManiFest.xml中添加对应的intent-filter和mete-data就能被设置中搜索到，就能加载该选项，剩下的是添加一下几个附加信息。最好是有该apk提供公司的技术支持，不然有混淆的代码就比较难进行更改、回编译了。 1234567891011121314151617181920212223242526272829303132/** * 在settings中显示在哪个分类中 * The key used to get the category from metadata of activities of action * &#123;@link #EXTRA_SETTINGS_ACTION&#125; * The value must be one of: * &lt;li&gt;com.android.settings.category.wireless&lt;/li&gt; * &lt;li&gt;com.android.settings.category.device&lt;/li&gt; * &lt;li&gt;com.android.settings.category.personal&lt;/li&gt; * &lt;li&gt;com.android.settings.category.system&lt;/li&gt; */private static final String EXTRA_CATEGORY_KEY = \"com.android.settings.category\";/** * 在settings中显示的图标 * Name of the meta-data item that should be set in the AndroidManifest.xml * to specify the icon that should be displayed for the preference. */public static final String META_DATA_PREFERENCE_ICON = \"com.android.settings.icon\";/** * 在settings中显示的标题 * Name of the meta-data item that should be set in the AndroidManifest.xml * to specify the title that should be displayed for the preference. */public static final String META_DATA_PREFERENCE_TITLE = \"com.android.settings.title\";/** * 在settings中显示的描述语句 * Name of the meta-data item that should be set in the AndroidManifest.xml * to specify the summary text that should be displayed for the preference. */public static final String META_DATA_PREFERENCE_SUMMARY = \"com.android.settings.summary\"; 在TileUtils.java的白名单中添加对应的包名。这个也是Android考虑到的一些安全上的问题，没有添加到白名单上面的包名，就不会显示出来。 123/// Extra package white list for add item to Settings @&#123;private static final String[] EXTRA_PACKAGE_WHITE_LIST = &#123;&#125;;/// @&#125; 最后就是全编，刷机验证了。 相比android6.0，在7.0上添加功能选项显得更简单了，只需要写好了功能，在Settings的AndroidManifest.xml中添加必要的参数，或者是在独立的apk中AndroidManifest.xml中配置必要的参数，再在TileUtils.java中添加包名就好了。需要修改的地方更少了，并且Google将很方方法放到了com.android.settinglibs里，精简了一部分代码。","tags":[{"name":"开发","slug":"开发","permalink":"https://daynearby.github.io/tags/开发/"}]},{"title":"刚开始参加工作","date":"2017-02-10T09:00:36.000Z","path":"2017/02/10/impressions-work-6-months/","text":"刚开始工作，什么都不懂。 那么将加班当成一种常态吧。只是因为我什么都不懂。 勤劳一点，学多一点。也是对自己玩过来的几年负责。 换种心态：拿3k工资，干8k的活，出去就是至少能上8k。 工作了也要保持爱好，因为工作仅仅是工作，并不是生活的全部，只是生活的一部分。","tags":[{"name":"随笔","slug":"随笔","permalink":"https://daynearby.github.io/tags/随笔/"}]},{"title":"阳春 绿道","date":"2017-02-10T08:59:28.000Z","path":"2017/02/10/journey-yangchun-lvdao/","text":"","tags":[{"name":"摄影","slug":"摄影","permalink":"https://daynearby.github.io/tags/摄影/"}]},{"title":"常用命令，问题解决思路","date":"2017-02-10T02:31:18.000Z","path":"2017/02/10/article-title/","text":"设置模块1.settings为入口，该DashboardSummary.java作为显示系统设置，在onresume（）时通过动态建立设置选项，选项的内容来自settingsActivity中。当设备的屏幕比较大的时候，就显示在左边，当尺寸比较小的时候全屏显示该fragment。（由布局文件决定）。2.每个activity（也就是置的每个选项的类）继承SettingsActivity，使用PreferenceScreen作为列表显示，在xml使用preferenceHeader控件，作为一级界面，以列表的形式显示选项，并且在该activity或者是fragment中处理点击逻辑，如：界面的跳转，使用preferenceFragment实现显示第二级界面，。3.每个功能模块入口的类应该是：功能名字+Settings。那么每个功能模块的都是继承preferenceFragment。 蓝牙每次读取的模式，结果都是false，那么就没有显示下面的扫描设置123final ContentResolver resolver = getActivity().getContentResolver();final boolean bleScanningMode = Settings.Global.getInt( resolver, Settings.Global.BLE_SCAN_ALWAYS_AVAILABLE, 0) == 1; 取出的值是0, 0 == 1？ 2016-07-27storage assess framework (ASF)存储访问框架：是google提供的文件浏览访问框架，统一UI效果。 闹钟设置，在响闹铃之后，再设置铃声，那么这个算是另外再设置一个铃声，而不是当前的铃声，那么该闹铃也当然是停止，其他手机厂商也是这样的。 大字体，在布局上面显得窄，那么久可以稍微增加一下间距。 分屏的提示文字，这个可以直接进行修改，但是..还没找到什么时候出现分屏的提示，这个需要探索一下 2016-07-28lock_to_app_toast 固定显示后，点击返回键的toastscreen_pinning_description 一开始固定屏幕的引导提示 2016-08-04手机中的宏定义，文件位置system/build.prop,权限：644 2016-08-12单编不产生odex文件，在Android.mk中添加：LOCAL_DEX_PREOPT := false 2016-08-18retropfit okhttp volley 2016-08-19dragger2通过inject实现实例与构造函数的关联，通过Component实现参数的关联，通过model实现参数的初始化关联，通过provide实现参数的关联。 2016-08-22XDA lumia 525 Android 6.0 ！！！！ ####2016-09-01add by yangfujin@wind-mobi.com on 2016-09-01 for bug 129593 enduser版：需要添加GMS包，GMS包版本询问开发经理。GMS包添加到vender目录下编译之前需要clean一次source quick_build.sh ;wind_lunch E189_ctc user new ;make BUILD_GMS=yes -j24 2&gt;&amp;1 | tee build.log 2016-09-13####2016-09-231.判断铃声是否有效:RingManager.validRingtoneUri 2016-09-251.查看端口占用（5037 adb调试端口）：1netstat -ano | findstr \"5037\" 2.查看全部的进程1tasklist 3.杀指定的进程pid1tskill pid 2016-09-271.adnroid.os.SystemProperties 如果属性名称以“ro.”开头，那么这个属性被视为只读属性。一旦设置，属性值不能改变。 如果属性名称以“persist.”开头，当设置这个属性时，其值也将写入/data/property。 2016-09-291.查看设备的屏幕分辨率：adb shell wm size 2016-10-131.使用 android.os.SystemProperties.set()方法保存系统属性，应用清单文件中需要声明1android:sharedUserId=\"android.uid.system\" 否则不能进行保存，或者是保存了几秒，又恢复原来的属性值了。 2016-10-191.发版本：GMS + OTA1make BUILD_GMS=yes -j32 2&gt;&amp;1 | tee build.log &amp;&amp; make BUILD_GMS=yes -j32 otapackage 2016-10-201.快速编译system.img，可以使用这个命令： 12make systemimage make snode 快速打包 2.快速编译boot.img，可以使用以下命令: 1make bootimage 3.快速编译userdata.img，可以使用以下命令: 1make userdataimage-nodeps 2016-11-121.启动一个activity：12$ adb shell am start -n \"com.example.dashboard/com.example.dashboard.MainActivity\" -aandroid.intent.action.MAIN -c android.intent.category.LAUNCHER 2.查看设备信息（序列号、当前连接wifi密码等）：adb shell cat /data/misc/wifi/*.conf 3.发送广播：am broadcast -a &lt;广播动作&gt; ， am broadcast -a com.smz.mybroadcast 2016-11-141.打开mtklog： ##3646633## 2.录屏：1adb shell screenrecord /sdcard/demo.mp4 这条命令相当于按了设备的Backkey键1adb shell input keyevent 4 可以解锁屏幕1adb shell input keyevent 82 在屏幕上做划屏操作，前四个数为坐标点，后面是滑动的时间（单位毫秒）1adb shell input swipe 50 250 250 250 500 在屏幕上点击坐标点x=50 y=250的位置。1adb shell input tap 50 250 输入字符abc1adb shell input text abc 2016-11-221.定位模式：高精度模式（通过gps、无线网络、移动网络、蓝牙进行定位）、节电模式（通过无线网络、移动网络、蓝牙进行定位），仅限设备（通过GPS进行定位）在小部件上用上述三种模式的切换，再点击一下是关闭 2016-12-061.获取当前运行的activity1adb shell dumpsys activity top 2016-12-07是用adb命令时，经常出现ADB server didn’t ACK这种错误，主要原因是adb端口号被占用，可以通过以下方法找到是什么应用占用了端口号 1、当通过CMD启动adb服务。这个时候会提示启动失败“ADB server didn’t ACK”。服务启动失败的原因有很多，一般是端口绑定失败。 2、在cmd中输入adb nodaemon server查看端口绑定信息，一般会报cannot bind ‘tcp:5037’ 3、查看是什么占用了端口，在cmd中输入netstat -ano | findstr “5037” 就可以看出 4.输入命令：tasklist /fi “pid eq 784” 查找出是因为sjk_daemon.exe占用了该端口 最后利用任务管理器杀掉该任务即可 2016-12-081.查看进程的内存空间：1adb shell dumpsys meminfo -a com.android.launcher3 2016-12-151.截图命令1adb shell /system/bin/screencap -p /sdcard/screen.png 2016-12-181.更新了系统中公共方法，需要更新api1make update-api 实际上不需要更新API，我们只是内部使用，又不是SDK，所以一般通过添加注解就可以了：@hide 2016-12-221.获取控件显示的宽高12int[] location = new int[2]; v.getLocationOnScreen(location); 2017-03-27framework 中隐藏输入法，若显示了1234567InputMethodManagerInternal inputMethodManagerInternal = LocalServices.getService(InputMethodManagerInternal.class); if (inputMethodManagerInternal != null) &#123; // Hide the current IME to avoid problems with animations from IME adjustment when // attaching the docked stack. inputMethodManagerInternal.hideCurrentInputMethod(); &#125; 2017-05-15多用户Tag12345ActivityManager: Starting userid:0 fg:trueActivityManager: User switch timeout: from 10 to 0ActivityManager: Continue user switch oldUser #10, newUser #0BroadcastQueue: Timeout of broadcast BroadcastRecord&#123;cd49af6 u-1 android.intent.action.USER_STARTING&#125; - receiver=android.app.LoadedApk$ReceiverDispatcher$InnerReceiver@54b90a1, started 60001ms ago 2017-06-15获取当前显示的布局1adb shell uiautomator dump &amp;&amp; adb pull /sdcard/window_dump.xml","tags":[{"name":"开发","slug":"开发","permalink":"https://daynearby.github.io/tags/开发/"}]}]